# Migrate the database

With the Prisma schema defined, you will run migrations to create the actual tables in the database.

```bash
npx prisma migrate dev --name 'init'
```

1. Save the migration

   - Prisma Migrate will take a snapshot of your schema and figure out the SQL commands necessary to carry out the migration.
   - Prisma will save the migration file containing the SQL commands to the newly created `prisma/migrations` folder.

2. Execute the migration

   - Prisma Migrate will execute the SQL in the migration file to create the underlying tables in your database.

3. Generate Prisma Client

   - Prisma will generate Prisma Client based on your latest schema.
   - Since you did not have the Client library installed, the CLI will install it for you as well. You should see the `@prisma/client` package inside `dependencies` in your `package.json` file.
   - Prisma Client is a TypeScript query builder auto-generated from your Prisma schema. It is tailored to your Schema and will be used to send queries to the database.

# Perform input validation

Pipes operate on the arguments being processed by a route handler. Nest invokes a pipe before the route handler, and the pipe receives the arguments destined for the route handler. Pipes are similar to middleware, but the scope of pipes is limited to processing input arguments.

Pipes have two typical use cases:

- `Validation`

  - Evaluate input data and, if valid, pass it through unchanged; otherwise, throw an exception when the data is incorrect.

- `Transformation`

  - Transform input data to the desired form (e.g., from string to integer).

A NestJS validation pipe will check the arguments passed to a route. If the arguments are valid, the pipe will pass the arguments to the route handler without any modification. However, if the arguments violate any of the specified validation rules, the pipe will throw an exception.

# Strip unnecessary properties from client requests

It is possible to send additional properties that are not defined in the DTO. This can lead to unforeseen bugs or security issues. For example, you could manually pass invalid `createdAt` and `updatedAt` values to the `POST /articles` endpoint. Since TypeScript type information is not available at run-time, your application will not be able to identify that these fields are not available in the DTO.

```json
{
  "title": "example-title",
  "description": "example-description",
  "body": "example-body",
  "published": true,
  "createdAt": "2010-06-08T18:20:29.309Z",
  "updatedAt": "2021-06-02T18:20:29.310Z"
}
```

In this way, you can inject invalid values. You have created an article that has an `updatedAt` value that precedes `createdAt`, which does not make sense.

To prevent this, you will need to filter any unnecessary fields/properties from client requests. NestJS provides an out-of-the-box for this as well. All you need to do is pass the `whitelist: true` option when initializing `ValidationPipe` inside your application.

```ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true, // filter any unnecessary fields from client requests
  }),
);
```

`ValidationPipe` will automatically remove all non-whitelisted properties, where "non-whitelisted" means properties without any validation decorators. It's important to note that this option will filter all properties without validation decorators, even if they are defined in the DTO.

# Handle exceptions by using exception filters

## Advantages of a dedicated exception layer

In many cases, an exception will automatically be generated by your application code. In such cases, you should process the exception and return the appropriate HTTP error to the user.

While it's possible to handle exceptions case by case in each controller manually, it is not a good idea for many reasons.

- It will clutter your core application logic with a lot of error handling code.
- Many of your endpoints will deal with similar errors, such as a resource not being found. You will have to duplicate the same error handling code in many places.
- It would be hard to change your error handling logic since it is scattered across many locations.

To solve these issues, NestJS has an `exception layer` which is responsible for processing unhandled exceptions across your application. In NestJS, you can create `exception filters` that define how to handle different kinds of exceptions thrown inside your application.

## NestJS global exception filter

NestJS has a global exception filter, which catches all unhandled exceptions.

Send two requests to the `POST /articles` endpoint with the following body.

```json
{
  "title": "Let’s build a REST API with NestJS and Prisma.",
  "description": "NestJS Series announcement.",
  "body": "NestJS is one of the hottest Node.js frameworks around. In this series, you will learn how to build a backend REST API with NestJS, Prisma, PostgreSQL and Swagger.",
  "published": true
}
```

The first request will succeed, but the second request will fail because you already created an article with the same `title` field. You will get the following error.

```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

You should see the following error.

```
[Nest] 6803  - 12/06/2022, 3:25:40 PM   ERROR [ExceptionsHandler]
Invalid `this.prisma.article.create()` invocation in
/Users/tasinishmam/my-code/median/src/articles/articles.service.ts:11:32

   8 constructor(private prisma: PrismaService) {}
   9
  10 create(createArticleDto: CreateArticleDto) {
→ 11   return this.prisma.article.create(
  Unique constraint failed on the fields: (`title`)
Error:
Invalid `this.prisma.article.create()` invocation in
/Users/tasinishmam/my-code/median/src/articles/articles.service.ts:11:32
8 constructor(private prisma: PrismaService) {}
   9
  10 create(createArticleDto: CreateArticleDto) {
→ 11   return this.prisma.article.create(
  Unique constraint failed on the fields: (`title`)
```

From the logs you can see that Prisma Client throws an unique contraint validation error because of the `title` field, which is marked as `@unique` in the Prisma schema. The exception is of type `PrismaClientKnownRequestError` and is exported at the Prisma namespace level.

Since the `PrismaClientKnownRequestError` is not being handled directly by your application, it is automatically processed by the built-in global exception filter. This filter generates the HTTP `500 Internal Server Error` response.

## Create a manual exception filter

You will create a custom exception filter to handle the `PrismaClientKnownRequestError`. This filter will catch all exceptions of type `PrismaClientKnownRequestError` and return a clear user friendly error message to the user.

Generate a filter class by using the Nest CLI.

```bash
nest generate filter prisma-client-exception
```

Update the `catch` method implementation in `PrismaClientExceptionFilter` as follows.

```ts
import { ArgumentsHost, Catch } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';
import { Prisma } from '@prisma/client';

@Catch(Prisma.PrismaClientKnownRequestError)
export class PrismaClientExceptionFilter extends BaseExceptionFilter {
  catch(exception: Prisma.PrismaClientKnownRequestError, host: ArgumentsHost) {
    console.error(exception);

    // default 500 error code
    super.catch(exception, host);
  }
}
```

You have made the following changes.

1. To ensure that this filter catches exceptions of type `PrismaClientKnownRequestError`, you added it to the `@Catch` decorator.
2. The exception filter extneds the `BaseExceptionFilter` class from the NestJS core package. This class provides a default implementation for the `catch` method that returns an "internal server error" response to the user.
3. You added a `console.error` statement to log the error message to the console. This is useful for debugging purposes.

Prisma throws the `PrismaClientKnownRequestError` for many different kinds of errors. So you will need to figure out how to extract the error code from the `PrismaClientKnownRequestError` exception. The `PrismaClientKnownRequestError` exception has a `code` property that contains the error code. You can find the list of error codes in the **Prisma Error Message reference**.

The error code is `P2002`, which occurs for unique constraint violations. You will now update the `catch` method to throw an HTTP `409 Conflict` response in case of this error. You will also provide a custom error message to the user.

Update your exception filter implementation like this.

```ts
import { ArgumentsHost, Catch, HttpStatus } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';
import { Prisma } from '@prisma/client';
import { Response } from 'express';

@Catch(Prisma.PrismaClientKnownRequestError)
export class PrismaClientExceptionFilter extends BaseExceptionFilter {
  catch(exception: Prisma.PrismaClientKnownRequestError, host: ArgumentsHost) {
    console.error(exception.message);
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const message = exception.message.replace(/\n/g, '');

    switch (exception.code) {
      case 'P2002': {
        const status = HttpStatus.CONFLICT;
        response.status(status).json({
          statusCode: status,
          message,
        });
        break;
      }
      default:
        // default 500 error code
        super.catch(exception, host);
        break;
    }
  }
}
ts;
```

You are accessing the underlying framework `Response` object and directly modifying the response. By default, `express` is the HTTP framework used by NestJS under the hood. For any exception code besides `P2002`, you are sending the default "Internal server error" response.

## Apply the exception filter to your application

For the `PrismaClientExceptionFilter` to come into effect, you need to apply it to a certain scope. An exception filter can be scoped to individual routes(method-scoped), entire controllers(controller-scoped) or across the entire application(global-scoped).

Apply the exception filter to your entire application by updating the `main.ts` file.

```ts
const { httpAdapter } = app.get(HttpAdapterHost);
app.useGlobalFilters(
  new PrismaClientExceptionFilter(httpAdapter), //
);
```

Now, try making the same request to the `POST /articles` endpoint. This time you will get a more user-friendly error message.

```json
{
  "statusCode": 409,
  "message": "Invalid `this.prismaService.article.create()` invocation in/Users/taeyoon/Desktop/lecture/nestjs/nestjs-repo/median/src/articles/articles.service.ts:13:39  10 ) {}  11   12 create(createArticleDto: CreateArticleDto) {→ 13   return this.prismaService.article.create(Unique constraint failed on the fields: (`title`)"
}
```

Since the `PrismaClientExceptionFilter` is a global filter, it can handle this particular type of error for all routes in your application.

Recommend extending the exception filter implementation to handle other errors as well. For example, you can add a case to handle the `P2025` error code, which occurs when a record is not found in the database. You should return the status code `HttpStatus.NOT_FOUND` for this error.

# Bonus: Handle Prisma exceptions with the `nestjs-prisma` package

There is a dedicated package for using Prisma with NestJS called `nestjs-prisma` that you can also use to handle Prisma exceptions. This package is an excellent option to consider because it removes a lot of boilerplate code.

Instructions on installing and using the package are available in the `nestjs-prisma documentation`. When using this package, you will not need to manually create a separate `prisma` module and service, as this package will automatically make them for you.

# Exclude `password` field from the response body

The `password` field is returned in the response body of the different endpoints.

You have two options to fix this issue.

1. Manually remove the password from the response body in the controller route handlers.
2. Use an `interceptor` to automatically remove the password from the response body.

The first option is error prone and results in unnecessary code duplication. So, you will use the second option.

## Use the `ClassSerializerInterceptor` to remove a field from the response

`Interceptors` in NestJS allow you to hook into the request-response cycle and allow you to execute extra logic before and after the route handler is executed. In this case, you will use it to remove the `password` field from the response body.

NestJS has a built-in [`ClassSerializerInterceptor`](https://docs.nestjs.com/techniques/serialization) that can be used to transform objects. You will use this interceptor to remove the `password` field from the response object.

First, enable `ClassSerializerInterceptor` globally by updating `main.ts`

```ts
app.useGlobalInterceptors(
  new ClassSerializerInterceptor(app.get(Reflector)), //
);
```

The `ClassSerializerInterceptor` uses the `class-transformer` package to define how to transform objects. Use the `@Exclude()` decorator to exclude to `password` field in the `UserEntity` class.

```ts
import { ApiProperty } from '@nestjs/swagger';
import { User } from '@prisma/client';
import { Exclude } from 'class-transformer';

export class UserEntity implements User {
  @ApiProperty()
  id: number;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiProperty()
  name: string;

  @ApiProperty()
  email: string;

  // omitting the @ApiProperty decorator will only hide the password property from the Swagger documentation
  // the property will still be visible in the response body
  @Exclude()
  password: string;
}
```

If you try using the `GET /users/:id` endpoint again, you'll notice that the `password` field is still being exposed. This is because, currently the route handlers in your controller returns the `User` type generated by Prisma Client. The `ClassSerializerInterceptor` only works with classes decorated with the `@Exclude()` decorator. In this case, it's the `UserEntity` class. So, you need to update the route handlers to return the `UserEntity` type instead.

First, you need to create a constructor that will instantiate a `UserEntity` object.

```ts
import { ApiProperty } from '@nestjs/swagger';
import { User } from '@prisma/client';
import { Exclude } from 'class-transformer';

export class UserEntity implements User {
  constructor(partial: Partial<UserEntity>) {
    // this에 partial 객체의 속성 복사해 붙여넣고, this 리턴
    Object.assign(this, partial);
  }

  @ApiProperty()
  id: number;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiProperty()
  name: string;

  @ApiProperty()
  email: string;

  // omitting the @ApiProperty decorator will only hide the password property from the Swagger documentation
  // the property will still be visible in the response body
  @Exclude()
  password: string;
}
```

The constructor takes an object and uses the `Object.assign()` method to copy the properties from the `partial` object to the `UserEntity` instance. The type of `partial` is `Partial<UserEntity>`. This means that the `partial` object can contain any subset of the properties defined in the `UserEntity` class.

Next, update the `UsersController` route handlers to return `UserEntity` instead of `Prisma.User` objects.

```ts
@Post()
@ApiCreatedResponse({
  type: UserEntity,
})
async create(@Body() createUserDto: CreateUserDto) {
  return new UserEntity(await this.usersService.create(createUserDto));
}
```

Now, the password should be omitted from the response object.

# Returning the author along with an article

In order to fetch the `author` you have to make an addtional request to the `GET /users/:id` endpoint. This is not ideal if you need both the article and its author because you need to make two API requests. You can improve this by returning the `author` along with the `Article` object.

The data access logic is implemented inside the `ArticlesService`. Update the `findOne()` method to return the `author` along with the `Article` object.

```ts
// articles.service.ts
findOne(id: number) {
  return this.prismaService.article.findUnique({
    where: {
      id,
    },
    // return the author along with the Article object
    include: {
      author: true,
    },
  });
}
```

If you test the `GET /articles/:id` endpoint, you'll notice that the author of an article, if present, is included in the response object. However, there's a problem. The `password` field is exposed again.

The reason for this issue is very similar to last time. Currently, the `ArticlesController` returns instances of Prisma generated types, whereas the `ClassSerializerInterceptor` works with the `UserEntity` class. To fix this, you will update the implementation of the `ArticleEntity` class and make sure it initializes the `author` property with an instance of `UserEntity`.

```ts
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Article } from '@prisma/client';
import { UserEntity } from 'src/users/entities/user.entity';

export class ArticleEntity implements Article {
  @ApiProperty()
  id: number;

  @ApiProperty()
  title: string;

  @ApiPropertyOptional({
    nullable: true,
  })
  description: string | null;

  @ApiProperty()
  body: string;

  @ApiProperty()
  published: boolean;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiPropertyOptional({
    nullable: true,
  })
  authorId: number | null;

  @ApiPropertyOptional({
    type: UserEntity,
  })
  author?: UserEntity;

  constructor({ author, ...data }: Partial<ArticleEntity>) {
    Object.assign(this, data);

    if (author) this.author = new UserEntity(author);
  }
}
```

You are using the `Object.assign()` method to copy the properties from the `data` object to the `ArticleEntity` instance. The `author` property, if it is present, is initialized as an instance of `UserEntity`.

Now update the `ArticlesController` to return instances of `ArticleEntity` objects.

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  ParseIntPipe,
  NotFoundException,
} from '@nestjs/common';
import { ArticlesService } from './articles.service';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';
import { ApiCreatedResponse, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { ArticleEntity } from './entities/article.entity';

@ApiTags('articles')
@Controller('articles')
export class ArticlesController {
  constructor(private readonly articlesService: ArticlesService) {}

  /**
   * POST /articles endpoint
   * @param createArticleDto article 생성 데이터
   * @returns 생성한 article 데이터
   */
  @Post()
  @ApiCreatedResponse({
    type: ArticleEntity,
  })
  async create(@Body() createArticleDto: CreateArticleDto) {
    return new ArticleEntity(
      await this.articlesService.create(createArticleDto),
    );
  }

  /**
   * GET /articles/drafts endpoint
   * route to fetch all unpublished articles
   */
  @Get('drafts')
  @ApiOkResponse({
    type: ArticleEntity,
    isArray: true,
  })
  async findDrafts() {
    const drafts = await this.articlesService.findDrafts();
    return drafts.map((draft) => new ArticleEntity(draft));
  }

  /**
   * GET /articles endpoint
   */
  @Get()
  @ApiOkResponse({
    type: ArticleEntity,
    isArray: true,
  })
  async findAll() {
    const articles = await this.articlesService.findAll();
    return articles.map((article) => new ArticleEntity(article));
  }

  /**
   * GET /articles/:id endpoint
   * @param id article id
   * @returns an article whose id is equal to the id param
   */
  @Get(':id')
  @ApiOkResponse({
    type: ArticleEntity,
  })
  async findOne(@Param('id', ParseIntPipe) id: number) {
    return new ArticleEntity(await this.articlesService.findOne(id));
  }

  /**
   * PATCH /articles/:id endpoint
   * @param id article id
   * @param updateArticleDto article 수정 데이터
   * @returns 수정한 article 데이터
   */
  @Patch(':id')
  @ApiOkResponse({
    type: ArticleEntity,
  })
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateArticleDto: UpdateArticleDto,
  ) {
    return new ArticleEntity(
      await this.articlesService.update(id, updateArticleDto),
    );
  }

  /**
   * DELETE /articles/:id endpoint
   * @param id article id
   * @returns 삭제한 article 데이터
   */
  @Delete(':id')
  @ApiOkResponse({
    type: ArticleEntity,
  })
  async remove(@Param('id', ParseIntPipe) id: number) {
    return new ArticleEntity(await this.articlesService.remove(id));
  }
}
```

Now, `GET /articles/:id` returns the `author` object without the `password` field.

# Install and configure `passport`

`passport` is a popular authentication library for Node.js applications. It is highly configurable and supports a wide range of authentication strategies. It is meant to be used with the `Express` web framework, which NestJS is built on. NestJS has a first-party integration with `passport` called `@nestjs/passport` that makes it easy to use in your NestJS application.

Install the following packages.

```bash
npm install @nestjs/passport passport @nestjs/jwt passport-jwt
npm install -D @types/passport-jwt
```

You can configure `passport` in your application.

```ts
// auth.module.ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaModule } from 'src/prisma/prisma.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';

export const jwtSecret = 'dlfkjdaslfji4j5ioj34oij1kndfk;and4i95u19';

@Module({
  imports: [
    PrismaModule, //
    PassportModule,
    JwtModule.register({
      secret: jwtSecret,
      signOptions: {
        expiresIn: '5m', // 30s, 7d, 24h
      },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService],
})
export class AuthModule {}
```

The `@nestjs/passport` module provides a `PassportModule` that you can import into your application. The `PassportModule` is a wrapper around the `passport` library that provides NestJS specific utilities.

You also configured a `JwtModule` that you will use to generate and verify JWTs. The `JwtModule` is a wrapper arount the `jsonwebtoken` library. The `secret` provides a secret key that is used to sign the JWTs. The `expiresIn` object defines the expiration time of the JWTs. It is currently set to 5 minutes.

# Implement JWT authentication strategy

In Passport, a strategy is responsible for authenticating requests, which it accomplishes by implementing an authentication mechanism. You will implement a JWT authentication strategy that will be used to authenticate users.

You will not using the `passport` package directly, but rather interact with the wrapper package `@nestjs/passport`, which will call the `passport` package under the hood. To configure a strategy with `@nestjs/passport`, you need to create a class that extends the `PassportStrategy` class. You will need to do two main things in this class.

1. You will pass JWT strategy specific options and configuration to the `super()` method in the constructor.
2. A `validate()` callback method that will interact with your database to fetch a user based on the JWT payload. If a user is found, the `validate()` method is expected to return the user object.

First, create a new file called `jwt.strategy.ts` inside the `src/auth/strategy` directory.

```bash
touch src/auth/strategy/jwt.strategy.ts
```

Implement the `JwtStrategy` class.

```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UsersService } from 'src/users/users.service';
import { jwtSecret } from '../auth.module';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(
    private usersService: UsersService, //
  ) {
    // pass JWT strategy specific options and configuration to the super() method
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: jwtSecret,
    });
  }

  // validate() callback method that will interact with your database to fetch a user based on the JWT payload
  // if a user is found, the validate() method is expected to return the user object
  async validate(payload: { userId: number }) {
    const user = await this.usersService.findOne(payload.userId);
    if (!user) throw new UnauthorizedException();

    return user;
  }
}
```

You have created a `JwtStrategy` class that extends the `PassportStrategy` class. The `PassportStrategy` class takes two arguments: a strategy implementation and the name of the strategy. Here you are using a predefined strategy from the `passport-jwt` library.

You are passing some options to the `super()` method in the constructor. The `jwtFromRequest` option expects a method that can be used to extract the JWT from the request. In this case, you will use the standard approach of supplying a bearer token in the Authorization header of our API requests. The `secretOrKey` option tells the strategy what secret to use to verify the JWT.

For the `passport-jwt`, Passport first verifies the JWT's signature and decodes the JSON. The decoded JSON is then passed to the `validate()` method. Based on the way JWT signing works, you're guaranteed receiving a valid token that was previously signed and issued by your app. The `validate()` method is expected to return a user object. If the user is not found, the `validate()` method throws an error.

Add the new `JwtStrategy` as a provider in the `AuthModule`.

```ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaModule } from 'src/prisma/prisma.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { UsersModule } from 'src/users/users.module';
import { JwtStrategy } from './strategy/jwt.strategy';

// never store the secret directly in your codebase
// NestJS provides the @nestjs/config package for loading secrets from environment variables
export const jwtSecret = 'dlfkjdaslfji4j5ioj34oij1kndfk;and4i95u19';

@Module({
  imports: [
    PrismaModule, //
    PassportModule,
    JwtModule.register({
      secret: jwtSecret,
      signOptions: {
        expiresIn: '5m', // 30s, 7d, 24h
      },
    }),
    UsersModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
})
export class AuthModule {}
```

Now the `JwtStrategy` can be used by other modules. You have also added the `UsersModule` in the `imports`, because the `UsersService` is being used in the `JwtStrategy` class.

To make `UsersService` accessible in the `JwtStrategy` class, you also need to add it in the `exports` of the `UsersModule`.

```ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { PrismaModule } from 'src/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

# Impleent JWT auth guard

`Guards` are a NestJS construct that determines whether a request should be allowed to proceed or not. You will implement a custom `JwtAuthGuard` that will be used to protect routes that require authentication.

Create a new file called `jwt-auth.guard.ts` inside the `src/auth` directory.

```bash
touch src/auth/jwt-auth.guard.ts
```

Implement the `JwtAuthGuard` class.

```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

The `AuthGuard` class expects the name of the strategy. In this case, you are using the `JwtStrategy` that you implemented, which is named `jwt`.

You can now use this guard as a decorator to protect your endpoints. Add the `JwtAuthGuard` to routes in the `UsersController`.

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ApiCreatedResponse, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { UserEntity } from './entities/user.entity';
import { JwtAuthGuard } from 'src/auth/jwt-auth.guard';

@ApiTags('users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  /**
   * POST /users endpoint
   * @param createUserDto 유저 생성 데이터
   * @returns 생성한 유저 데이터
   */
  @Post()
  @ApiCreatedResponse({
    type: UserEntity,
  })
  async create(@Body() createUserDto: CreateUserDto) {
    return new UserEntity(await this.usersService.create(createUserDto));
  }

  /**
   * GET /users endpoint
   * @returns 유저 데이터 목록
   */
  @Get()
  @UseGuards(JwtAuthGuard)
  @ApiOkResponse({
    type: UserEntity,
    isArray: true,
  })
  async findAll() {
    const users = await this.usersService.findAll();
    return users.map((user) => new UserEntity(user));
  }

  /**
   * GET /users/:id endpoint
   * @param id 유저 id
   * @returns 유저 데이터
   */
  @Get(':id')
  @UseGuards(JwtAuthGuard)
  @ApiOkResponse({
    type: UserEntity,
  })
  async findOne(@Param('id', ParseIntPipe) id: number) {
    return new UserEntity(await this.usersService.findOne(id));
  }

  /**
   * PATCH /users/:id endpoint
   * @param id 유저 id
   * @param updateUserDto 유저 수정 데이터
   * @returns 수정한 유저 데이터
   */
  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  @ApiOkResponse({
    type: UserEntity,
  })
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateUserDto: UpdateUserDto,
  ) {
    return new UserEntity(await this.usersService.update(id, updateUserDto));
  }

  /**
   * DELETE /users/:id endpoint
   * @param id 유저 id
   * @returns 삭제한 유저 데이터
   */
  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  @ApiOkResponse({
    type: UserEntity,
  })
  async remove(@Param('id', ParseIntPipe) id: number) {
    return new UserEntity(await this.usersService.remove(id));
  }
}
```

# Integrate authentication in Swagger

Currently there's no indication on Swagger that these endpoints are auth protected. You can add a `@ApiBearerAuth()` decorator to the controller to indicate that authentication is required.

```ts
@Delete(':id')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
@ApiOkResponse({
  type: UserEntity,
})
async remove(@Param('id', ParseIntPipe) id: number) {
  return new UserEntity(await this.usersService.remove(id));
}
```

It's currently not possible to authenticate yourself directly in Swagger so you can test these endpoints. To do this, you can add the `.addBearerAuth()` method call to the `SwaggerModule` setup in `main.ts`.

```ts
// main.ts
const swaggerConfig = new DocumentBuilder()
  .setTitle('Median')
  .setDescription('The Median API description')
  .setVersion('0.1')
  .addBearerAuth()
  .build();
```

You can now add a token by clicking on the `Authorize` button in Swagger. Swagger will add the token to your requests so you can query the protected endpoints.
