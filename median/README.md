# Migrate the database

With the Prisma schema defined, you will run migrations to create the actual tables in the database.

```bash
npx prisma migrate dev --name 'init'
```

1. Save the migration

   - Prisma Migrate will take a snapshot of your schema and figure out the SQL commands necessary to carry out the migration.
   - Prisma will save the migration file containing the SQL commands to the newly created `prisma/migrations` folder.

2. Execute the migration

   - Prisma Migrate will execute the SQL in the migration file to create the underlying tables in your database.

3. Generate Prisma Client

   - Prisma will generate Prisma Client based on your latest schema.
   - Since you did not have the Client library installed, the CLI will install it for you as well. You should see the `@prisma/client` package inside `dependencies` in your `package.json` file.
   - Prisma Client is a TypeScript query builder auto-generated from your Prisma schema. It is tailored to your Schema and will be used to send queries to the database.

# Perform input validation

Pipes operate on the arguments being processed by a route handler. Nest invokes a pipe before the route handler, and the pipe receives the arguments destined for the route handler. Pipes are similar to middleware, but the scope of pipes is limited to processing input arguments.

Pipes have two typical use cases:

- `Validation`

  - Evaluate input data and, if valid, pass it through unchanged; otherwise, throw an exception when the data is incorrect.

- `Transformation`

  - Transform input data to the desired form (e.g., from string to integer).

A NestJS validation pipe will check the arguments passed to a route. If the arguments are valid, the pipe will pass the arguments to the route handler without any modification. However, if the arguments violate any of the specified validation rules, the pipe will throw an exception.

# Strip unnecessary properties from client requests

It is possible to send additional properties that are not defined in the DTO. This can lead to unforeseen bugs or security issues. For example, you could manually pass invalid `createdAt` and `updatedAt` values to the `POST /articles` endpoint. Since TypeScript type information is not available at run-time, your application will not be able to identify that these fields are not available in the DTO.

```json
{
  "title": "example-title",
  "description": "example-description",
  "body": "example-body",
  "published": true,
  "createdAt": "2010-06-08T18:20:29.309Z",
  "updatedAt": "2021-06-02T18:20:29.310Z"
}
```

In this way, you can inject invalid values. You have created an article that has an `updatedAt` value that precedes `createdAt`, which does not make sense.

To prevent this, you will need to filter any unnecessary fields/properties from client requests. NestJS provides an out-of-the-box for this as well. All you need to do is pass the `whitelist: true` option when initializing `ValidationPipe` inside your application.

```ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true, // filter any unnecessary fields from client requests
  }),
);
```

`ValidationPipe` will automatically remove all non-whitelisted properties, where "non-whitelisted" means properties without any validation decorators. It's important to note that this option will filter all properties without validation decorators, even if they are defined in the DTO.

# Handle exceptions by using exception filters

## Advantages of a dedicated exception layer

In many cases, an exception will automatically be generated by your application code. In such cases, you should process the exception and return the appropriate HTTP error to the user.

While it's possible to handle exceptions case by case in each controller manually, it is not a good idea for many reasons.

- It will clutter your core application logic with a lot of error handling code.
- Many of your endpoints will deal with similar errors, such as a resource not being found. You will have to duplicate the same error handling code in many places.
- It would be hard to change your error handling logic since it is scattered across many locations.

To solve these issues, NestJS has an `exception layer` which is responsible for processing unhandled exceptions across your application. In NestJS, you can create `exception filters` that define how to handle different kinds of exceptions thrown inside your application.

## NestJS global exception filter

NestJS has a global exception filter, which catches all unhandled exceptions.

Send two requests to the `POST /articles` endpoint with the following body.

```json
{
  "title": "Let’s build a REST API with NestJS and Prisma.",
  "description": "NestJS Series announcement.",
  "body": "NestJS is one of the hottest Node.js frameworks around. In this series, you will learn how to build a backend REST API with NestJS, Prisma, PostgreSQL and Swagger.",
  "published": true
}
```

The first request will succeed, but the second request will fail because you already created an article with the same `title` field. You will get the following error.

```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

You should see the following error.

```
[Nest] 6803  - 12/06/2022, 3:25:40 PM   ERROR [ExceptionsHandler]
Invalid `this.prisma.article.create()` invocation in
/Users/tasinishmam/my-code/median/src/articles/articles.service.ts:11:32

   8 constructor(private prisma: PrismaService) {}
   9
  10 create(createArticleDto: CreateArticleDto) {
→ 11   return this.prisma.article.create(
  Unique constraint failed on the fields: (`title`)
Error:
Invalid `this.prisma.article.create()` invocation in
/Users/tasinishmam/my-code/median/src/articles/articles.service.ts:11:32
8 constructor(private prisma: PrismaService) {}
   9
  10 create(createArticleDto: CreateArticleDto) {
→ 11   return this.prisma.article.create(
  Unique constraint failed on the fields: (`title`)
```

From the logs you can see that Prisma Client throws an unique contraint validation error because of the `title` field, which is marked as `@unique` in the Prisma schema. The exception is of type `PrismaClientKnownRequestError` and is exported at the Prisma namespace level.

Since the `PrismaClientKnownRequestError` is not being handled directly by your application, it is automatically processed by the built-in global exception filter. This filter generates the HTTP `500 Internal Server Error` response.

## Create a manual exception filter

You will create a custom exception filter to handle the `PrismaClientKnownRequestError`. This filter will catch all exceptions of type `PrismaClientKnownRequestError` and return a clear user friendly error message to the user.

Generate a filter class by using the Nest CLI.

```bash
nest generate filter prisma-client-exception
```

Update the `catch` method implementation in `PrismaClientExceptionFilter` as follows.

```ts
import { ArgumentsHost, Catch } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';
import { Prisma } from '@prisma/client';

@Catch(Prisma.PrismaClientKnownRequestError)
export class PrismaClientExceptionFilter extends BaseExceptionFilter {
  catch(exception: Prisma.PrismaClientKnownRequestError, host: ArgumentsHost) {
    console.error(exception);

    // default 500 error code
    super.catch(exception, host);
  }
}
```

You have made the following changes.

1. To ensure that this filter catches exceptions of type `PrismaClientKnownRequestError`, you added it to the `@Catch` decorator.
2. The exception filter extneds the `BaseExceptionFilter` class from the NestJS core package. This class provides a default implementation for the `catch` method that returns an "internal server error" response to the user.
3. You added a `console.error` statement to log the error message to the console. This is useful for debugging purposes.

Prisma throws the `PrismaClientKnownRequestError` for many different kinds of errors. So you will need to figure out how to extract the error code from the `PrismaClientKnownRequestError` exception. The `PrismaClientKnownRequestError` exception has a `code` property that contains the error code. You can find the list of error codes in the **Prisma Error Message reference**.

The error code is `P2002`, which occurs for unique constraint violations. You will now update the `catch` method to throw an HTTP `409 Conflict` response in case of this error. You will also provide a custom error message to the user.

Update your exception filter implementation like this.

```ts
import { ArgumentsHost, Catch, HttpStatus } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';
import { Prisma } from '@prisma/client';
import { Response } from 'express';

@Catch(Prisma.PrismaClientKnownRequestError)
export class PrismaClientExceptionFilter extends BaseExceptionFilter {
  catch(exception: Prisma.PrismaClientKnownRequestError, host: ArgumentsHost) {
    console.error(exception.message);
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const message = exception.message.replace(/\n/g, '');

    switch (exception.code) {
      case 'P2002': {
        const status = HttpStatus.CONFLICT;
        response.status(status).json({
          statusCode: status,
          message,
        });
        break;
      }
      default:
        // default 500 error code
        super.catch(exception, host);
        break;
    }
  }
}
ts;
```

You are accessing the underlying framework `Response` object and directly modifying the response. By default, `express` is the HTTP framework used by NestJS under the hood. For any exception code besides `P2002`, you are sending the default "Internal server error" response.

## Apply the exception filter to your application

For the `PrismaClientExceptionFilter` to come into effect, you need to apply it to a certain scope. An exception filter can be scoped to individual routes(method-scoped), entire controllers(controller-scoped) or across the entire application(global-scoped).

Apply the exception filter to your entire application by updating the `main.ts` file.

```ts
const { httpAdapter } = app.get(HttpAdapterHost);
app.useGlobalFilters(
  new PrismaClientExceptionFilter(httpAdapter), //
);
```

Now, try making the same request to the `POST /articles` endpoint. This time you will get a more user-friendly error message.

```json
{
  "statusCode": 409,
  "message": "Invalid `this.prismaService.article.create()` invocation in/Users/taeyoon/Desktop/lecture/nestjs/nestjs-repo/median/src/articles/articles.service.ts:13:39  10 ) {}  11   12 create(createArticleDto: CreateArticleDto) {→ 13   return this.prismaService.article.create(Unique constraint failed on the fields: (`title`)"
}
```

Since the `PrismaClientExceptionFilter` is a global filter, it can handle this particular type of error for all routes in your application.

Recommend extending the exception filter implementation to handle other errors as well. For example, you can add a case to handle the `P2025` error code, which occurs when a record is not found in the database. You should return the status code `HttpStatus.NOT_FOUND` for this error.

# Bonus: Handle Prisma exceptions with the `nestjs-prisma` package

There is a dedicated package for using Prisma with NestJS called `nestjs-prisma` that you can also use to handle Prisma exceptions. This package is an excellent option to consider because it removes a lot of boilerplate code.

Instructions on installing and using the package are available in the `nestjs-prisma documentation`. When using this package, you will not need to manually create a separate `prisma` module and service, as this package will automatically make them for you.
